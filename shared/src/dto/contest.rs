use crate::dto::game::GameDto;
use crate::dto::venue::VenueDto;
use crate::models::contest::Contest;
use crate::models::venue::Venue;
use chrono::{DateTime, FixedOffset};
use serde::{Deserialize, Serialize};
use validator::{Validate, ValidationError};

/// Data Transfer Object for Contest
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct ContestDto {
    /// Contest's ID (optional for creation, will be set by ArangoDB if empty)
    #[serde(rename = "_id", default)]
    pub id: String,
    #[serde(default)] // Optional when creating, will be generated by backend
    pub name: String,
    pub start: DateTime<FixedOffset>,
    pub stop: DateTime<FixedOffset>,
    pub venue: VenueDto,
    pub games: Vec<GameDto>,
    pub outcomes: Vec<OutcomeDto>,
    /// ID of the player who created this contest (set by backend)
    #[serde(default)]
    pub creator_id: String,
    /// When this contest was created (set by backend)
    #[serde(default)]
    pub created_at: Option<DateTime<FixedOffset>>,
}

impl Validate for ContestDto {
    fn validate(&self) -> Result<(), validator::ValidationErrors> {
        let mut errors = validator::ValidationErrors::new();
        // Validate nested fields
        if let Err(e) = self.venue.validate() {
            use validator::ValidationErrorsKind;
            errors
                .errors_mut()
                .entry("venue".into())
                .or_insert(ValidationErrorsKind::Struct(Box::new(e)));
        }
        // Validate stop > start
        if self.stop <= self.start {
            use validator::ValidationErrorsKind;
            let mut err = ValidationError::new("invalid_dates");
            err.message = Some("stop must be after start".into());
            errors
                .errors_mut()
                .entry("stop".into())
                .or_insert(ValidationErrorsKind::Field(vec![err]));
        }
        if errors.errors().is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

/// Data Transfer Object for Contest Outcome
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct OutcomeDto {
    pub player_id: String,
    pub place: String,
    pub result: String,
    #[serde(default)]
    pub email: String,
    #[serde(default)]
    pub handle: String,
}

impl From<&Contest> for ContestDto {
    fn from(contest: &Contest) -> Self {
        Self {
            id: contest.id.clone(),
            name: contest.name.clone(),
            start: contest.start,
            stop: contest.stop,
            venue: VenueDto::from(
                &Venue::new(
                    String::new(),                               // id
                    String::new(),                               // rev
                    String::new(),                               // display_name
                    String::new(),                               // formatted_address
                    String::new(),                               // place_id
                    0.0,                                         // lat
                    0.0,                                         // lng
                    "UTC".to_string(),                           // timezone
                    crate::models::venue::VenueSource::Database, // source
                )
                .unwrap_or_else(|_| Venue {
                    id: String::new(),
                    rev: String::new(),
                    display_name: String::new(),
                    formatted_address: String::new(),
                    place_id: String::new(),
                    lat: 0.0,
                    lng: 0.0,
                    timezone: "UTC".to_string(),
                    source: crate::models::venue::VenueSource::Database,
                }),
            ),
            games: Vec::new(),
            outcomes: Vec::new(),
            creator_id: contest.creator_id.clone(),
            created_at: Some(contest.created_at),
        }
    }
}

impl From<ContestDto> for Contest {
    fn from(dto: ContestDto) -> Self {
        Self {
            id: dto.id,
            rev: String::new(),
            name: dto.name, // Use provided name or empty string (will be generated by backend)
            start: dto.start,
            stop: dto.stop,
            creator_id: dto.creator_id,
            created_at: dto
                .created_at
                .unwrap_or_else(|| chrono::Utc::now().fixed_offset()),
        }
    }
}

impl ContestDto {
    /// Updates the Contest with data from a ContestDto
    pub fn update_contest(&self, contest: &mut Contest) {
        contest.id = self.id.clone();
        contest.name = self.name.clone();
        contest.start = self.start;
        contest.stop = self.stop;
        contest.creator_id = self.creator_id.clone();
        if let Some(created_at) = self.created_at {
            contest.created_at = created_at;
        }
        // Note: venue and games are managed through edge collections
        // timezone is not present in Contest model
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::DateTime;
    use pretty_assertions::assert_eq;
    use test_log::test;
    use validator::Validate;

    fn create_test_contest_dto() -> ContestDto {
        ContestDto {
            id: "contest/test-contest".to_string(),
            name: "Test Contest".to_string(),
            start: DateTime::parse_from_rfc3339("2023-07-15T14:00:00Z").unwrap(),
            stop: DateTime::parse_from_rfc3339("2023-07-15T16:00:00Z").unwrap(),
            venue: VenueDto {
                id: "venue/test-venue".to_string(),
                display_name: "Test Venue".to_string(),
                formatted_address: "123 Test St, Test City, TC 12345".to_string(),
                place_id: "test_place_id".to_string(),
                lat: 40.7128,
                lng: -74.0060,
                timezone: "America/New_York".to_string(),
                source: crate::models::venue::VenueSource::Database,
            },
            games: vec![GameDto {
                id: "game/test-game".to_string(),
                name: "Test Game".to_string(),
                year_published: Some(2020),
                bgg_id: Some(12345),
                description: Some("A test game".to_string()),
                source: crate::models::game::GameSource::Database,
            }],
            outcomes: vec![OutcomeDto {
                player_id: "player/test-player-1".to_string(),
                place: "1".to_string(),
                result: "won".to_string(),
                email: "player1@example.com".to_string(),
                handle: "player1".to_string(),
            }],
            creator_id: "player/test-creator".to_string(),
            created_at: Some(DateTime::parse_from_rfc3339("2023-07-15T10:00:00Z").unwrap()),
        }
    }

    fn create_test_outcome_dto() -> OutcomeDto {
        OutcomeDto {
            player_id: "player/test-player".to_string(),
            place: "1".to_string(),
            result: "won".to_string(),
            email: "player@example.com".to_string(),
            handle: "player".to_string(),
        }
    }

    #[test]
    fn test_contest_dto_creation() {
        let dto = create_test_contest_dto();
        assert_eq!(dto.name, "Test Contest");
        assert_eq!(dto.id, "contest/test-contest");
        assert_eq!(dto.games.len(), 1);
        assert_eq!(dto.outcomes.len(), 1);
    }

    #[test]
    fn test_contest_dto_validation_success() {
        let dto = create_test_contest_dto();
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_validation_empty_name() {
        let mut dto = create_test_contest_dto();
        dto.name = "".to_string(); // Empty name is allowed (will be generated)
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_validation_invalid_dates() {
        let mut dto = create_test_contest_dto();
        // Set stop time before start time
        dto.stop = DateTime::parse_from_rfc3339("2023-07-15T13:00:00Z").unwrap();
        assert!(dto.validate().is_err());
    }

    #[test]
    fn test_contest_dto_validation_empty_venue() {
        let mut dto = create_test_contest_dto();
        dto.venue.display_name = "".to_string();
        assert!(dto.validate().is_err());
    }

    #[test]
    fn test_contest_dto_serialization() {
        let dto = create_test_contest_dto();
        let json = serde_json::to_string(&dto).unwrap();
        let deserialized: ContestDto = serde_json::from_str(&json).unwrap();
        assert_eq!(dto.id, deserialized.id);
        assert_eq!(dto.name, deserialized.name);
        assert_eq!(dto.start, deserialized.start);
        assert_eq!(dto.stop, deserialized.stop);
        assert_eq!(dto.games.len(), deserialized.games.len());
        assert_eq!(dto.outcomes.len(), deserialized.outcomes.len());
    }

    #[test]
    fn test_contest_dto_serializes_start_stop_as_utc_iso8601() {
        // Build a DTO with UTC start/stop
        let mut dto = create_test_contest_dto();
        dto.start = DateTime::parse_from_rfc3339("2024-01-15T14:30:00Z").unwrap();
        dto.stop = DateTime::parse_from_rfc3339("2024-01-15T16:30:00Z").unwrap();
        let json = serde_json::to_string(&dto).unwrap();

        // Ensure the JSON contains UTC indicators (either Z or +00:00)
        let has_utc_start = json.contains("\"start\":\"2024-01-15T14:30:00Z\"")
            || json.contains("\"start\":\"2024-01-15T14:30:00+00:00\"");
        let has_utc_stop = json.contains("\"stop\":\"2024-01-15T16:30:00Z\"")
            || json.contains("\"stop\":\"2024-01-15T16:30:00+00:00\"");
        assert!(
            has_utc_start,
            "start not serialized in UTC ISO8601: {}",
            json
        );
        assert!(has_utc_stop, "stop not serialized in UTC ISO8601: {}", json);
    }

    #[test]
    fn test_contest_dto_from_contest() {
        let contest = Contest {
            id: "contest/test".to_string(),
            rev: "1".to_string(),
            name: "Test Contest".to_string(),
            start: DateTime::parse_from_rfc3339("2023-07-15T14:00:00Z").unwrap(),
            stop: DateTime::parse_from_rfc3339("2023-07-15T16:00:00Z").unwrap(),
            creator_id: "player/test-creator".to_string(),
            created_at: DateTime::parse_from_rfc3339("2023-07-15T10:00:00Z").unwrap(),
        };

        let dto = ContestDto::from(&contest);
        assert_eq!(dto.id, "contest/test");
        assert_eq!(dto.name, "Test Contest");
        assert_eq!(dto.venue.timezone, "UTC");
    }

    #[test]
    fn test_contest_from_contest_dto() {
        let dto = create_test_contest_dto();
        let contest = Contest::from(dto.clone());

        assert_eq!(contest.id, dto.id);
        assert_eq!(contest.name, dto.name);
        assert_eq!(contest.start, dto.start);
        assert_eq!(contest.stop, dto.stop);
    }

    #[test]
    fn test_contest_dto_update_contest() {
        let dto = create_test_contest_dto();
        let mut contest = Contest {
            id: "contest/old".to_string(),
            rev: "1".to_string(),
            name: "Old Contest".to_string(),
            start: DateTime::parse_from_rfc3339("2023-01-01T00:00:00Z").unwrap(),
            stop: DateTime::parse_from_rfc3339("2023-01-01T02:00:00Z").unwrap(),
            creator_id: "player/test-creator".to_string(),
            created_at: DateTime::parse_from_rfc3339("2023-01-01T00:00:00Z").unwrap(),
        };

        dto.update_contest(&mut contest);

        assert_eq!(contest.id, dto.id);
        assert_eq!(contest.name, dto.name);
        assert_eq!(contest.start, dto.start);
        assert_eq!(contest.stop, dto.stop);
    }

    #[test]
    fn test_outcome_dto_creation() {
        let outcome = create_test_outcome_dto();
        assert_eq!(outcome.player_id, "player/test-player");
        assert_eq!(outcome.place, "1");
        assert_eq!(outcome.result, "won");
        assert_eq!(outcome.email, "player@example.com");
        assert_eq!(outcome.handle, "player");
    }

    #[test]
    fn test_outcome_dto_serialization() {
        let outcome = create_test_outcome_dto();
        let json = serde_json::to_string(&outcome).unwrap();
        let deserialized: OutcomeDto = serde_json::from_str(&json).unwrap();
        assert_eq!(outcome.player_id, deserialized.player_id);
        assert_eq!(outcome.place, deserialized.place);
        assert_eq!(outcome.result, deserialized.result);
        assert_eq!(outcome.email, deserialized.email);
        assert_eq!(outcome.handle, deserialized.handle);
    }

    #[test]
    fn test_contest_dto_with_empty_games() {
        let mut dto = create_test_contest_dto();
        dto.games = vec![];
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_with_empty_outcomes() {
        let mut dto = create_test_contest_dto();
        dto.outcomes = vec![];
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_with_multiple_games() {
        let mut dto = create_test_contest_dto();
        dto.games.push(GameDto {
            id: "game/test-game-2".to_string(),
            name: "Test Game 2".to_string(),
            year_published: Some(2021),
            bgg_id: Some(54321),
            description: Some("Another test game".to_string()),
            source: crate::models::game::GameSource::Database,
        });
        assert!(dto.validate().is_ok());
        assert_eq!(dto.games.len(), 2);
    }

    #[test]
    fn test_contest_dto_with_multiple_outcomes() {
        let mut dto = create_test_contest_dto();
        dto.outcomes.push(OutcomeDto {
            player_id: "player/test-player-2".to_string(),
            place: "2".to_string(),
            result: "lost".to_string(),
            email: "player2@example.com".to_string(),
            handle: "player2".to_string(),
        });
        assert!(dto.validate().is_ok());
        assert_eq!(dto.outcomes.len(), 2);
    }

    #[test]
    fn test_contest_dto_with_different_timezone() {
        let mut dto = create_test_contest_dto();
        dto.venue.timezone = "America/New_York".to_string();
        dto.start = DateTime::parse_from_rfc3339("2023-07-15T14:00:00-05:00").unwrap();
        dto.stop = DateTime::parse_from_rfc3339("2023-07-15T16:00:00-05:00").unwrap();
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_edge_cases() {
        // Test with very long name
        let mut dto = create_test_contest_dto();
        dto.name = "A".repeat(1000);
        assert!(dto.validate().is_ok());

        // Test with special characters in name
        dto.name = "Test Contest & Tournament (2023) - Special Edition!".to_string();
        assert!(dto.validate().is_ok());

        // Test with empty timezone (should use default)
        dto.venue.timezone = "".to_string();
        assert!(dto.validate().is_ok());
    }

    #[test]
    fn test_contest_dto_creator_tracking() {
        let dto = create_test_contest_dto();
        assert_eq!(dto.creator_id, "player/test-creator");
        assert!(dto.created_at.is_some());
        assert_eq!(
            dto.created_at.unwrap(),
            DateTime::parse_from_rfc3339("2023-07-15T10:00:00Z").unwrap()
        );
    }

    #[test]
    fn test_contest_dto_serialization_with_creator() {
        let dto = create_test_contest_dto();
        let json = serde_json::to_string(&dto).unwrap();
        let deserialized: ContestDto = serde_json::from_str(&json).unwrap();

        assert_eq!(dto.id, deserialized.id);
        assert_eq!(dto.name, deserialized.name);
        assert_eq!(dto.creator_id, deserialized.creator_id);
        assert_eq!(dto.created_at, deserialized.created_at);
    }

    #[test]
    fn test_contest_dto_from_contest_with_creator() {
        let contest = Contest {
            id: "contest/test".to_string(),
            rev: "1".to_string(),
            name: "Test Contest".to_string(),
            start: DateTime::parse_from_rfc3339("2023-07-15T14:00:00Z").unwrap(),
            stop: DateTime::parse_from_rfc3339("2023-07-15T16:00:00Z").unwrap(),
            creator_id: "player/test-creator".to_string(),
            created_at: DateTime::parse_from_rfc3339("2023-07-15T10:00:00Z").unwrap(),
        };

        let dto = ContestDto::from(&contest);
        assert_eq!(dto.id, "contest/test");
        assert_eq!(dto.name, "Test Contest");
        assert_eq!(dto.creator_id, "player/test-creator");
        assert_eq!(
            dto.created_at,
            Some(DateTime::parse_from_rfc3339("2023-07-15T10:00:00Z").unwrap())
        );
    }

    #[test]
    fn test_contest_from_contest_dto_with_creator() {
        let dto = create_test_contest_dto();
        let contest = Contest::from(dto.clone());

        assert_eq!(contest.id, dto.id);
        assert_eq!(contest.name, dto.name);
        assert_eq!(contest.start, dto.start);
        assert_eq!(contest.stop, dto.stop);
        assert_eq!(contest.creator_id, dto.creator_id);
        assert_eq!(contest.created_at, dto.created_at.unwrap());
    }

    #[test]
    fn test_contest_dto_update_contest_with_creator() {
        let dto = create_test_contest_dto();
        let mut contest = Contest {
            id: "contest/old".to_string(),
            rev: "1".to_string(),
            name: "Old Contest".to_string(),
            start: DateTime::parse_from_rfc3339("2023-01-01T00:00:00Z").unwrap(),
            stop: DateTime::parse_from_rfc3339("2023-01-01T02:00:00Z").unwrap(),
            creator_id: "player/old-creator".to_string(),
            created_at: DateTime::parse_from_rfc3339("2023-01-01T00:00:00Z").unwrap(),
        };

        dto.update_contest(&mut contest);

        assert_eq!(contest.id, dto.id);
        assert_eq!(contest.name, dto.name);
        assert_eq!(contest.start, dto.start);
        assert_eq!(contest.stop, dto.stop);
        assert_eq!(contest.creator_id, dto.creator_id);
        assert_eq!(contest.created_at, dto.created_at.unwrap());
    }
}
